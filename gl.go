// Copyright 2014 The Azul3D Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Code generated by this program is also under
// the above license.

// glwrap is a tool for generating Go OpenGL wrappers.
package main

import (
	"io"
	"text/template"
)

const goglTemplate = `// Copyright 2014 The Azul3D Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// This source file was automatically generated using glwrap.{{range $tag := .BuildTags}}
// +build {{$tag}}{{end}}
// +build {{.DebugBuildTag}}

// Package {{.API}} implements Go bindings to {{.Title}}.
//
// Debugging OpenGL applications is made easy by using the build tag for this
// package "opengl_debug", that is:
//
// go install -tags "opengl_debug" my/package/path
//
// Debugging using this build tag has both advantages and disadvantages:
//
// Advantage: glGetError() is ran directly after each OpenGL function call for
// you, and in the event of an error a panic will occur in addition to a full
// OpenGL stack trace being dumped to stdout before the panic occurs.
//
// Advantage: Batching cannot be turned on, this can help identify batching
// related bugs (due to incorrect memory management).
//
// Disadvantage: Applications compiled with the opengl_debug build tag are slow
// and will not run at full speed due to both disabled batching and the
// additional glGetError call for each OpenGL call.
//
package {{.API}}

/*
#cgo linux LDFLAGS: -lGL
#include "gl.h"
*/
import "C"

import(
	"unsafe"
	"strconv"
	"strings"{{if .Debug}}
	"fmt"{{end}}
)

// Context represents a single OpenGL context's API access.
//
// Since CGO (Go to C) calls are expensive in large quantities as they require
// a context switch due to Go's and C's incompatibile ABI, and since even
// modern OpenGL applications can make several hundred thousands of calls per
// frame, it can become a large bottleneck.
//
// To help remedy this specific bottleneck, batching can be used. When OpenGL
// calls are made and batching is turned on, instead of calls being executed
// immedietly they are stored in a queue and executed later upon a single call
// to the Execute() method.
//
// When batching is turned off and OpenGL calls are made, they are executed
// immedietly, the Execute() method is no-op, and large amounts of OpenGL calls
// will suffer from the performance degration described above.
//
// Additionally, batching may be turned on or off at runtime (even in-between
// OpenGL calls) using the SetBatching() method at runtime.
//
// Note that since batched OpenGL calls are only truly made upon invocation of
// the Execute() method, the memory for pointer arguments to OpenGL function
// calls must remain valid at least untill Execute() is called or else memory
// corruption is possible.
//
// Also note that OpenGL functions which return anything, such as the GetString
// function, cannot be queued for batching because they require that the value
// be immedietly returned. Also, if the function in question relies on previous
// OpenGL commands being executed first, you are responsible for calling the
// Execute() method.
//
// Since batching requires some extra effort on the programmer's side, and
// since debugging applications with batching turned on is more difficult, it
// is by default turned off.
type Context struct {
	c *C.gl_wrap_context
	batch []C.gl_wrap_batch_func
	batching bool
	loadedShaderVersion, loadedVersion bool
	major, minor, release int
	shaderMajor, shaderMinor, shaderRelease int
	vendorVersion, vendorShaderVersion string
	extensions map[string]bool{{if $.Debug}}
	stack []string
	insideBeginEnd bool{{end}}
}

// New returns a new initialized Context with batching turned on.
func New() *Context {
	c := new(Context)
	c.c = new(C.gl_wrap_context)
	c.batching = false
	return c
}{{if $.Debug}}

// Panic causes a Go panic with the err string and also dumps the OpenGL stack
// before the panic.
//
// This function is only defined if the application is compiled with the
// "opengl_debug" build tag.
func (c *Context) Panic(err string) {
	fmt.Println("Panic:", err)
	fmt.Println("OpenGL call stack (last 500 - most recent first).")

	// Print stack now
	count := 0
	for i := len(c.stack); i > 0; i-- {
		count++
		fmt.Printf("%3.d. %s\n", count, c.stack[i-1])
	}

	panic(fmt.Sprintf("OpenGL: %s", err))
}

func (c *Context) trace(name, args string) {
	if name == "GetError" {
		// Avoid infinite recursion
		return
	} else if name == "Begin" {
		// Can't use GetError inside Begin/End pair
		c.insideBeginEnd = true
	} else if name == "End" {
		// Can start using GetError again now that we're outside the Begin/End pair
		c.insideBeginEnd = false
	}

	c.stack = append(c.stack, fmt.Sprintf("%s(%s)", name, args))
	if len(c.stack) > 500 {
		c.stack = c.stack[len(c.stack)-500:len(c.stack)]
	}
	if !c.insideBeginEnd {
		err := c.GetError()
		if err != NO_ERROR {
			switch err {
			case INVALID_ENUM:
				c.Panic("GL_INVALID_ENUM: An unacceptable value was specified for an enumerated argument.")
			case INVALID_VALUE:
				c.Panic("GL_INVALID_VALUE: A numeric argument is out of range.")
			case INVALID_OPERATION:
				c.Panic("GL_INVALID_OPERATION: The specified operation is not allowed in the current state.")
			case INVALID_FRAMEBUFFER_OPERATION:
				c.Panic("GL_INVALID_FRAMEBUFFER_OPERATION: The framebuffer object is not complete.")
			case OUT_OF_MEMORY:
				c.Panic("GL_OUT_OF_MEMORY: There is not enough memory left to execute the command.")
			case STACK_UNDERFLOW:
				c.Panic("GL_STACK_UNDERFLOW: Operation would cause an internal stack to underflow.")
			case STACK_OVERFLOW:
				c.Panic("GL_STACK_OVERFLOW: Operation would cause an internal stack to overflow.")
			}
		}
	}
}{{end}}

// SetBatching turns on or off batching of this Context.
//
// If turning off batching using SetBatching(false), then an implicit call to
// Execute() which executes all the currently pending OpenGL function calls on
// this Context occurs.
//
// Default value is off (false).
func (c *Context) SetBatching(batching bool) {
	if !batching && len(c.batch) > 0 {
		c.Execute()
	}{{if not $.Debug}}
	c.batching = batching{{end}}
}

// Batching tells whether or not batching is on or off for this Context.
func (c *Context) Batching() bool {
	return c.batching
}

func (c *Context) push(f C.gl_wrap_batch_func) {
	c.batch = append(c.batch, f)
}

// Execute executes all the currently pending OpenGL function calls for this
// Context.
//
// This function executes pending calls regardless of whether or not batching
// is turned on.
func (c *Context) Execute() {
	if len(c.batch) > 0 {
		C.gl_wrap_batch_exec(
			c.c,
			(*C.gl_wrap_batch_func)(unsafe.Pointer(&c.batch[0])),
			C.int(len(c.batch)),
		)

		// Re-slice the batch
		c.batch = c.batch[:0]
	}
}

func (c *Context) parseVersionString(ver string) (major, minor, release int, vendor string) {
	if len(ver) == 0 {
		// Version string must not be empty
		return
	}

	// According to http://www.opengl.org/sdk/docs/man/xhtml/glGetString.xml
	//
	// the string returned may be 'major.minor' or 'major.minor.release'
	// and may be following by a space and any vendor specific information.

	// First locate a proper version string without vendor specific
	// information.
	var(
		versionString string
		err error
	)
	if strings.Contains(ver, " ") {
		// It must have vendor information
		split := strings.Split(ver, " ")
		if len(split) > 0 || len(split[0]) > 0 {
			// Everything looks good.
			versionString = split[0]
		} else {
			// Something must be wrong with their vendor string.
			return
		}

		// Store the vendor version information.
		vendor = ver[len(versionString):]
	} else {
		// No vendor information.
		versionString = ver
	}

	// We have a proper version string now without vendor information.
	dots := strings.Count(versionString, ".")
	if dots == 1 {
		// It's a 'major.minor' style string
		versions := strings.Split(versionString, ".")
		if len(versions) == 2 {
			major, err = strconv.Atoi(versions[0])
			if err != nil {
				return
			}

			minor, err = strconv.Atoi(versions[1])
			if err != nil {
				return
			}

		} else {
			return
		}

	} else if dots == 2 {
		// It's a 'major.minor.release' style string
		versions := strings.Split(versionString, ".")
		if len(versions) == 3 {
			major, err = strconv.Atoi(versions[0])
			if err != nil {
				return
			}

			minor, err = strconv.Atoi(versions[1])
			if err != nil {
				return
			}

			release, err = strconv.Atoi(versions[2])
			if err != nil {
				return
			}
		} else {
			return
		}
	}
	return
}

func (c *Context) initVersion() {
	c.loadedVersion = true
	versionString := String(c.GetString(VERSION))
	c.major, c.minor, c.release, c.vendorVersion = c.parseVersionString(versionString)
}

func (c *Context) initShaderVersion() {
	c.loadedShaderVersion = true
	versionString := String(c.GetString(SHADING_LANGUAGE_VERSION))
	c.shaderMajor, c.shaderMinor, c.shaderRelease, c.vendorShaderVersion = c.parseVersionString(versionString)
}

// Version returns the major and minor OpenGL version supported by the
// implementation.
//
// Additionally provided is the vendor-specific release version (E.g. a driver
// version number).
func (c *Context) Version() (major, minor, release int) {
	if !c.loadedVersion {
		c.initVersion()
	}
	return c.major, c.minor, c.release
}

// AtLeastVersion tells if the major and minor OpenGL version reported by
// c.Version() is at least minMajor, minMinor.
//
// It is implemented as:
//
//  if major > minMajor {
//      return true
//  } else if major == minMajor && minor >= minMinor {
//      return true
//  }
//  return false
//
func (c *Context) AtLeastVersion(minMajor, minMinor int) bool {
	if !c.loadedVersion {
		c.initVersion()
	}
	major, minor := c.major, c.minor
	if major > minMajor {
		return true
	} else if major == minMajor && minor >= minMinor {
		return true
	}
	return false
}

// AtLeastRelease tells if the release OpenGL version reported by c.Version()
// is at least minRelease.
//
// It is implemented as:
//
//  if release == 0 {
//      return true
//  } else if release >= minRelease {
//      return true
//  }
//  return false
//
func (c *Context) AtLeastRelease(minRelease int) bool {
	if !c.loadedVersion {
		c.initVersion()
	}
	release := c.release
	if release == 0 {
		return true
	} else if release >= minRelease {
		return true
	}
	return false
}

// VendorVersion returns the vendor-specific OpenGL version information.
//
// This string depends on the vendor of the graphics card/driver.
func (c *Context) VendorVersion() string {
	if !c.loadedVersion {
		c.initVersion()
	}
	return c.vendorVersion
}

// ShaderVersion returns the major and minor version of the supported GLSL
// shading language per the OpenGL implementation.
//
// Additionally provided is the vendor-specific release version (E.g. a driver
// version number).
func (c *Context) ShaderVersion() (major, minor, release int) {
	if !c.loadedShaderVersion {
		c.initShaderVersion()
	}
	return c.shaderMajor, c.shaderMinor, c.shaderRelease
}

// AtLeastShaderVersion tells if the major and minor GLSL version reported by
// c.ShaderVersion() is at least minMajor, minMinor.
//
// It is implemented as:
//
//  if major > minMajor {
//      return true
//  } else if major == minMajor && minor >= minMinor {
//      return true
//  }
//  return false
//
func (c *Context) AtLeastShaderVersion(minMajor, minMinor int) bool {
	if !c.loadedShaderVersion {
		c.initShaderVersion()
	}
	major, minor := c.shaderMajor, c.shaderMinor
	if major > minMajor {
		return true
	} else if major == minMajor && minor >= minMinor {
		return true
	}
	return false
}

// AtLeastShaderRelease tells if the release GLSL version reported by
// c.ShaderVersion() is at least minRelease.
//
// It is implemented as:
//
//  if release == 0 {
//      return true
//  } else if release >= minRelease {
//      return true
//  }
//  return false
//
func (c *Context) AtLeastShaderRelease(minRelease int) bool {
	if !c.loadedShaderVersion {
		c.initShaderVersion()
	}
	release := c.shaderRelease
	if release == 0 {
		return true
	} else if release >= minRelease {
		return true
	}
	return false
}

// VendorShaderVersion returns the vendor-specific shading language version
// information.
//
// This string depends on the vendor of the graphics card/driver.
func (c *Context) VendorShaderVersion() string {
	if !c.loadedShaderVersion {
		c.initShaderVersion()
	}
	return c.vendorShaderVersion
}

func (c *Context) initExtensions() {
	// Initialize extensions map
	extString := String(c.GetString(EXTENSIONS))
	if len(extString) > 0 {
		split := strings.Split(extString, " ")
		c.extensions = make(map[string]bool, len(split))
		for _, ext := range split {
			if len(ext) > 0 {
				c.extensions[ext] = true
			}
		}
	} else {
		c.extensions = make(map[string]bool)
	}
}

// Extensions returns a slice of strings which represents all the extensions
// supported by the OpenGL implementation.
//
// Internally a map is used to store them, so a copy in the form of a slice is
// returned.
func (c *Context) Extensions() []string {
	if c.extensions == nil {
		c.initExtensions()
	}
	cpy := make([]string, len(c.extensions))
	i := 0
	for ext, _ := range c.extensions {
		cpy[i] = ext
		i++
	}
	return cpy
}

// Extension tells if the specified extension is supported by the OpenGL
// implementation.
func (c *Context) Extension(name string) (supported bool) {
	if c.extensions == nil {
		c.initExtensions()
	}
	_, supported = c.extensions[name]
	return
}

// Declare non-batchable functions

{{range $index, $function := .Functions}}{{if .GoReturns}}func (c *Context) {{.GoName}}({{.GoArgs}}){{.GoReturns}}{{" {"}}{{if $.Debug}}
	defer c.trace("{{.GoName}}", {{if .CArgsPairs}}fmt.Sprintf("{{range $i, $e := .CArgsPairs}}%v{{if NeedComma $i $function.CArgsPairs}}{{", "}}{{end}}{{end}}", {{range $i, $e := .CArgsPairs}}{{.GoName}}{{if NeedComma $i $function.CArgsPairs}}{{", "}}{{end}}{{end}}){{else}}""{{end}}){{end}}
	{{.GoCCallDef}}
}

{{end}}{{end}}
// Declare batchable functions

{{range $index, $function := Batchable}}func (c *Context) {{.GoName}}({{.GoArgs}}){{.GoReturns}}{{" {"}}{{if $.Debug}}
	defer c.trace("{{.GoName}}", {{if .CArgsPairs}}fmt.Sprintf("{{range $i, $e := .CArgsPairs}}%v{{if NeedComma $i $function.CArgsPairs}}{{", "}}{{end}}{{end}}", {{range $i, $e := .CArgsPairs}}{{.GoName}}{{if NeedComma $i $function.CArgsPairs}}{{", "}}{{end}}{{end}}){{else}}""{{end}}){{end}}
	if c.batching {
		var glWrapHandlerArgs C.gl_wrap_handler_{{.CName}}_args
{{range $i, $j := .CArgsPairs}}		glWrapHandlerArgs.{{.GoHandlerDef}};
{{end}}
		c.push(C.gl_wrap_batch_func{
			jump_index: {{$index}},
			args: unsafe.Pointer(&glWrapHandlerArgs),
		})
	} else {
		{{.GoCCallDef}}
	}
}

{{end}}
`

func writeGoGL(out io.Writer, tmplData *TmplData, debug bool) error {
	var debugBuildTag string
	if debug {
		debugBuildTag = "opengl_debug"
	} else {
		debugBuildTag = "!opengl_debug"
	}

	funcMap := map[string]interface{}{
		"Batchable": func() (fns []TmplFunction) {
			for _, fn := range tmplData.Functions {
				if len(fn.GoReturns) == 0 {
					fns = append(fns, fn)
				}
			}
			return
		},
		"NeedComma": func(index int, s []TmplCArgPair) bool {
			return index != len(s)-1
		},
	}
	tmpl := template.Must(template.New("goglTemplate").Funcs(funcMap).Parse(goglTemplate))
	err = tmpl.Execute(out, map[string]interface{}{
		"DebugBuildTag": debugBuildTag,
		"BuildTags":     tmplData.BuildTags,
		"Functions":     tmplData.Functions,
		"Title":         tmplData.Title,
		"API":           tmplData.API,
		"Debug":         debug,
	})
	if err != nil {
		return err
	}
	return nil
}
