// Copyright 2014 The Azul3D Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Code generated by this program is also under
// the above license.

// glwrap is a tool for generating Go OpenGL wrappers.
package main

import (
	"io"
	"text/template"
)

const cHeaderTemplate = `// Copyright 2014 The Azul3D Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// This source file was automatically generated using glwrap.
// +build{{.BuildTags}}

#ifndef H_GLWRAP_{{.Name}}
#define H_GLWRAP_{{.Name}}


// OpenGL type definitions
{{range $element := .Types}}{{.CDefinition}}
{{end}}


// Define GLAPIENTRY for platforms that need it.
#ifndef GLAPIENTRY
#define GLAPIENTRY
#endif


// Typedefs for each OpenGL pointer function; GLAPIENTRY is required on Windows
// OS (but for other platforms is simply nothing).
{{range $element := .Functions}}typedef {{.CReturns}} (GLAPIENTRY* PFN{{.CCapsName}}PROC) ({{.CArgs}});
{{end}}

// gl_wrap_context holds the loaded function pointers for a given OpenGL
// context. Pointers are lazily-loaded upon first invocation of each function.
// through their appropriate gl_wrap_context_glFunction() counterparts.
typedef struct {
{{range $element := .Functions}}	PFN{{.CCapsName}}PROC {{.CName}}Proc;
{{end}}
} gl_wrap_context;

// Function prototype definitions for each appropriate OpenGL function.
{{range $element := .Functions}}inline {{.CReturns}} gl_wrap_context_{{.CName}}(gl_wrap_context* ctx{{.CNamedArgs}});
{{end}}

// Argument struct definitions for batch function handlers.
{{range $element := .Functions}}{{if not .GoReturns}}typedef struct {
{{range $i, $j := .CArgsPairs}}	{{.Type}} {{.Name}};
{{end}}{{"}"}} gl_wrap_handler_{{.CName}}_args;

{{end}}{{end}}

// Other custom definitions
typedef void (*gl_wrap_jump_handler)(gl_wrap_context* ctx, void* args);

typedef struct {
	int jump_index;
	void* args;
} gl_wrap_batch_func;

void gl_wrap_batch_exec(gl_wrap_context* ctx, gl_wrap_batch_func* funcs, int numFuncs);

#endif
`

func writeCHeader(out io.Writer, tmplFunctions []TmplFunction, tmplTypes []TmplType, name string) error {
	tmpl := template.Must(template.New("cHeaderTemplate").Parse(cHeaderTemplate))
	err = tmpl.Execute(out, map[string]interface{}{
		"Types":     tmplTypes,
		"Functions": tmplFunctions,
		"Name":      name,
	})
	if err != nil {
		return err
	}
	return nil
}
