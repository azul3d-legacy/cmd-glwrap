// Copyright 2014 The Azul3D Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Code generated by this program is also under
// the above license.

// glwrap is a tool for generating Go OpenGL wrappers.
package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

type TmplConstant struct {
	Name  string
	Value string
	Type  string
}

type TmplCArgPair struct {
	Name, Type   string
	GoName       string
	GoHandlerDef string
}

type TmplFunction struct {
	GoName, CName, CCapsName   string
	GoArgs, CArgs, CNamedArgs  string
	GoReturns, CReturns        string
	GoCCallDef, GoCHandlerArgs string
	CArgsPairs                 []TmplCArgPair
}

type TmplType struct {
	GoName, CName string
	CDefinition   string
}

type TmplData struct {
	BuildTags              []string
	API, Title, CapsName   string
	Functions              []TmplFunction
	Constants              []TmplConstant
	Types, CTypes          []TmplType
	enums, commands, types map[string]bool
}

func toGoType(s string) (goType string, needDefine bool) {
	// See page 13 of the OpenGL 4.3 specification at:
	//
	// http://www.opengl.org/registry/doc/glspec43.core.20120806.pdf
	//
	// For more details about data type sizes.
	switch s {
	case "GLboolean":
		goType = "uint8"
	case "GLbyte":
		goType = "byte"
	case "GLubyte":
		goType = "uint8"
	case "GLchar", "GLcharARB":
		goType = "byte"
	case "GLshort":
		goType = "int16"
	case "GLushort":
		goType = "uint16"
	case "GLint", "GLclampx":
		goType = "int32"
	case "GLuint":
		goType = "uint32"
	case "GLfixed":
		goType = "int32"
	case "GLint64", "GLint64EXT":
		goType = "int64"
	case "GLuint64", "GLuint64EXT":
		goType = "uint64"
	case "GLsizei":
		goType = "uint32"
	case "GLenum":
		goType = "int32"
	case "GLintptr", "GLintptrARB", "GLvdpauSurfaceNV":
		// GLintptr is signed, so it requires some care from the programmer.
		goType = "uintptr"
	case "GLsizeiptr", "GLsizeiptrARB":
		goType = "uintptr"
	case "GLbitfield":
		// Not sure if signed or unsigned, spec doesn't say anything except "Bitfield".
		goType = "uint32"
	case "GLhalf", "GLhalfARB", "GLhalfNV":
		goType = "uint16"
	case "GLfloat", "GLclampf":
		goType = "float32"
	case "GLdouble", "GLclampd":
		goType = "float64"
	case "GLvoid", "GLeglImageOES":
		goType = "unsafe.Pointer"

	default:
		needDefine = true
		if strings.HasPrefix(s, "GL") {
			goType = strings.ToUpper(string([]byte{s[2]})) + s[3:]
		}
	}
	return
}

func toGoName(s string) string {
	// see 'Keywords' section at http://golang.org/ref/spec
	switch s {
	case "break":
		return "pBreak"
	case "default":
		return "pDefault"
	case "func":
		return "pFunc"
	case "interface":
		return "pInterface"
	case "select":
		return "pSelect"

	case "case":
		return "pCase"
	case "defer":
		return "pDefer"
	case "go":
		return "pGo"
	case "map":
		return "pMap"
	case "struct":
		return "pStruct"

	case "chan":
		return "pChan"
	case "else":
		return "pElse"
	case "goto":
		return "pGoto"
	case "package":
		return "pPackage"
	case "switch":
		return "pSwitch"

	case "const":
		return "pConst"
	case "fallthrough":
		return "pFallthrough"
	case "if":
		return "pIf"
	case "range":
		return "pRange"
	case "type":
		return "pType"

	case "continue":
		return "pContinue"
	case "for":
		return "pFor"
	case "import":
		return "pImport"
	case "return":
		return "pReturn"
	case "var":
		return "pVar"
	case "c":
		// because "c" is always the *Context
		return "pC"
	}
	return s
}

func toCGOName(s string) string {
	switch s {
	case "break":
		return "_break"
	case "default":
		return "_default"
	case "func":
		return "_func"
	case "interface":
		return "_interface"
	case "select":
		return "_select"

	case "case":
		return "_case"
	case "defer":
		return "_defer"
	case "go":
		return "_go"
	case "map":
		return "_map"
	case "struct":
		return "_struct"

	case "chan":
		return "_chan"
	case "else":
		return "_else"
	case "goto":
		return "_goto"
	case "package":
		return "_package"
	case "switch":
		return "_switch"

	case "const":
		return "_const"
	case "fallthrough":
		return "_fallthrough"
	case "if":
		return "_if"
	case "range":
		return "_range"
	case "type":
		return "_type"

	case "continue":
		return "_continue"
	case "for":
		return "_for"
	case "import":
		return "_import"
	case "return":
		return "_return"
	case "var":
		return "_var"
	}
	return s
}

var (
	xmlFilePath string
	outputDir   string
	err         error

	apis = make(map[string]*TmplData)
)

func init() {
	log.SetFlags(0)
	flag.StringVar(&xmlFilePath, "xml", "", "XML specification file")
	flag.StringVar(&outputDir, "o", "", "output directory")
}

func hasAlphabetPrefix(s string) bool {
	upper := []byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	lower := []byte("abcdefghijklmnopqrstuvwxyz")
	for _, chr := range upper {
		if s[0] == chr {
			return true
		}
	}
	for _, chr := range lower {
		if s[0] == chr {
			return true
		}
	}
	return false
}

func undoXML(s string) string {
	s = strings.Replace(s, "<name>", "", -1)
	s = strings.Replace(s, "</name>", "", -1)
	s = strings.Replace(s, "<apientry/>", "", -1)
	s = strings.Replace(s, "&lt;", "<", -1)
	s = strings.Replace(s, "&gt;", ">", -1)
	s = strings.Replace(s, "&amp;", "&", -1)
	return s
}

func main() {
	flag.Parse()

	if len(xmlFilePath) == 0 || len(outputDir) == 0 {
		log.Println("Must specify -xml and -o flags.")
		flag.Usage()
	}

	xmlFile, err := os.Open(xmlFilePath)
	if err != nil {
		log.Fatal(err)
	}
	defer xmlFile.Close()

	xmlFileData, err := ioutil.ReadAll(xmlFile)
	if err != nil {
		log.Fatal(err)
	}

	var r Registry
	xml.Unmarshal(xmlFileData, &r)

	// Accumulate enumerants
	enumsLookup := make(map[string]string)
	for _, es := range r.Enums {
		for _, e := range es.Enum {
			if len(e.Value) > 0 {
				enumsLookup[e.Name] = e.Value
			}
		}
	}

	// Accumulate commands
	cmdLookup := make(map[string]Command)
	for _, c := range r.Commands.Command {
		cmdLookup[c.Proto.Name.String] = c
	}

	// Accumulate types
	typeLookup := make(map[string]Type)
	for _, t := range r.Types.Type {
		if len(t.Name) == 0 {
			// There is an empty-named type.
			continue
		}
		if strings.Contains(t.Name, "struct") {
			// There is some CL structs defined.
			continue
		}
		if t.Name == "GLvoid" {
			// We don't need unsafe.Pointer definition (obviously).
			continue
		}

		typeLookup[t.Name] = t
	}

	// API template data
	for _, feature := range r.Feature {
		// Accumulate template data within apis[feature.API]
		tmplData, ok := apis[feature.API]
		if !ok {
			tmplData = new(TmplData)
			tmplData.enums = make(map[string]bool)
			tmplData.commands = make(map[string]bool)
			tmplData.types = make(map[string]bool)
			apis[feature.API] = tmplData
		}

		// Find title
		if len(tmplData.Title) == 0 {
			tmplData.API = feature.API
			if tmplData.API == "gl" {
				tmplData.BuildTags = append(tmplData.BuildTags, "386 amd64")
			} else {
				tmplData.BuildTags = append(tmplData.BuildTags, "arm android")
			}

			switch feature.API {
			case "gl":
				tmplData.Title = "OpenGL"
				tmplData.CapsName = "OPENGL"
			case "gles1":
				tmplData.Title = "OpenGL ES"
				tmplData.CapsName = "OPENGL_ES_1"
			case "gles2":
				tmplData.Title = "OpenGL ES"
				tmplData.CapsName = "OPENGL_ES_2"
			default:
				tmplData.Title = feature.API
				tmplData.CapsName = feature.Name
			}
		}

		// Locate API types
		//
		// We don't iterate of typeLookup because it's a map and not in order.
		for _, t := range r.Types.Type {
			// Only if our API's match (e.g. 'gles1' and 'gles1') do we use the
			// type.
			if t.API == feature.API || len(t.API) == 0 {
				// Check if we already have it in the template data to avoid
				// repeating types multiple times.
				_, ok = tmplData.types[t.Raw]
				if ok {
					continue
				}
				tmplData.types[t.Raw] = true

				// Determine the C typedef
				cdef := undoXML(t.Raw)

				// KHR/khrplatform.h include is not marked with a specific API,
				// and it's not a valid include on non-GLES platforms, so we
				// check this here.
				if feature.API != "gl" || (feature.API == "gl" && t.NameAttr != "khrplatform") {
					// C types include *all* types, regardless of Go compatability.
					goName, _ := toGoType(t.Name)
					tmplData.CTypes = append(tmplData.CTypes, TmplType{
						GoName:      goName,
						CName:       t.Name,
						CDefinition: cdef,
					})
				}

				// Check if it's a valid type in typeLookup.
				_, ok := typeLookup[t.Name]
				if !ok {
					continue
				}

				goName, needDefine := toGoType(t.Name)
				if needDefine {
					tmplData.Types = append(tmplData.Types, TmplType{
						GoName:      goName,
						CName:       t.Name,
						CDefinition: cdef,
					})
				}
			}
		}

		for _, require := range feature.Require {
			// Locate required enumerants
			for _, enum := range require.Enum {
				_, ok := tmplData.enums[enum.Name]
				if ok {
					continue
				}
				tmplData.enums[enum.Name] = true

				value, ok := enumsLookup[enum.Name]
				if !ok {
					log.Printf("%q\n", enum.Name)
					log.Fatal("^ Failed to lookup named enumerant value!")
				}

				name := enum.Name
				if strings.HasPrefix(name, "GL_") {
					if hasAlphabetPrefix(name[3:]) {
						name = name[3:]
					}
				}

				// There is one (a few in the future?) value that exceed
				// GLenum's 32-bit size. We should check for this here and
				// assign those to GLuint64.
				valueType := "int32"
				uiValue, err := strconv.ParseUint(value, 0, 64)
				if err == nil && uiValue > math.MaxInt32 {
					valueType = "uint64"
				}
				tmplData.Constants = append(tmplData.Constants, TmplConstant{
					Name:  name,
					Value: value,
					Type:  valueType,
				})
			}

			// Locate required commands
			for _, cmd := range require.Command {
				// Check if command is already added to tmplData
				_, ok := tmplData.commands[cmd.Name]
				if ok {
					continue
				}
				tmplData.commands[cmd.Name] = true

				// Lookup detailed command
				cmdDetail, ok := cmdLookup[cmd.Name]
				if !ok {
					log.Printf("%q\n", cmd.Name)
					log.Fatal("^ Failed to lookup named command details!")
				}

				// Create Go function definition arguments
				argsBuf := new(bytes.Buffer)
				for _, param := range cmdDetail.Param {
					raw := param.Raw

					goParamType := param.ParamType.String
					if len(goParamType) == 0 {
						// Any void* param types are not stored in
						// param.ParamType.String, annoying!
						goParamType = "GLvoid"

						totalS := fmt.Sprintf("%v", param)
						isVoid := strings.Contains(totalS, "void")
						isStar := strings.Contains(totalS, "*")
						if !(isVoid && isStar) {
							log.Println(param)
							log.Fatal("^ Type is not void but we assumed it would be?")
						}
					}
					goParamType, _ = toGoType(goParamType)

					goParamName := toGoName(param.Name.String)

					stars := strings.Count(raw, "*")
					if stars > 0 {
						// It's a pointer
						var sStars string
						if goParamType == "unsafe.Pointer" {
							sStars = strings.Repeat("*", stars-1)
						} else {
							sStars = strings.Repeat("*", stars)
						}
						raw = goParamName + " " + sStars + goParamType
					} else {
						// Not a pointer
						raw = goParamName + " " + goParamType
					}

					fmt.Fprintf(argsBuf, "%s, ", raw)
				}

				args := argsBuf.String()
				if strings.HasSuffix(args, ", ") {
					// Strip ", " from end
					args = args[:len(args)-2]
				}

				// Locate Go return type
				goReturnType := cmdDetail.Proto.Returns.String
				if len(goReturnType) > 0 {
					goReturnType, _ = toGoType(goReturnType)

					stars := strings.Count(cmdDetail.Proto.Raw, "*")
					if stars > 0 {
						// Pointer return type
						sStars := strings.Repeat("*", stars)
						goReturnType = " " + sStars + goReturnType
					} else {
						// Normal return type
						goReturnType = " " + goReturnType
					}
				}

				// Locate C pointer return type
				cReturnType := cmdDetail.Proto.Returns.String
				if len(cReturnType) == 0 {
					cReturnType = "void"
				} else {
					stars := strings.Count(cmdDetail.Proto.Raw, "*")
					if stars > 0 {
						// Pointer return type
						sStars := strings.Repeat("*", stars)
						cReturnType += sStars
					}
				}

				// Create Go -> C function call arguments
				var (
					goCCallArgsBuf = new(bytes.Buffer)
					cArgsBuf       = new(bytes.Buffer)
					cNamedArgsBuf  = new(bytes.Buffer)
					cArgsPairs     []TmplCArgPair
				)
				if len(cmdDetail.Param) > 0 {
					fmt.Fprintf(cNamedArgsBuf, ", ")
				}
				for _, param := range cmdDetail.Param {
					raw := param.Raw

					goParamType := param.ParamType.String
					cParamType := param.ParamType.String
					if len(goParamType) == 0 {
						// Any void* param types are not stored in
						// param.ParamType.String, annoying!
						goParamType = "GLvoid"
						cParamType = "void"

						totalS := fmt.Sprintf("%v", param)
						isVoid := strings.Contains(totalS, "void")
						isStar := strings.Contains(totalS, "*")
						if !(isVoid && isStar) {
							log.Println(param)
							log.Fatal("^ Type is not void but we assumed it would be?")
						}
					}
					goParamName := toGoName(param.Name.String)

					stars := strings.Count(raw, "*")
					if stars > 0 {
						// It's a pointer
						sStars := strings.Repeat("*", stars)
						cParamType += sStars
						if goParamType == "GLvoid" {
							raw = goParamName
						} else {
							raw = fmt.Sprintf("(%sC.%s)(unsafe.Pointer(%s))", sStars, goParamType, goParamName)
						}
					} else {
						// Not a pointer
						raw = fmt.Sprintf("C.%s(%s)", goParamType, goParamName)
					}

					fmt.Fprintf(goCCallArgsBuf, "%s, ", raw)
					fmt.Fprintf(cArgsBuf, "%s, ", cParamType)
					fmt.Fprintf(cNamedArgsBuf, "%s %s, ", cParamType, param.Name.String)

					cgoCompatName := toCGOName(param.Name.String)
					goHandlerDef := fmt.Sprintf("%s = %s", cgoCompatName, raw)
					cArgsPairs = append(cArgsPairs, TmplCArgPair{
						Name:         param.Name.String,
						GoName:       goParamName,
						Type:         cParamType,
						GoHandlerDef: goHandlerDef,
					})
				}

				goCCallArgs := goCCallArgsBuf.String()
				if strings.HasSuffix(goCCallArgs, ", ") {
					// Strip ", " from end
					goCCallArgs = goCCallArgs[:len(goCCallArgs)-2]
				}
				goCHandlerArgs := goCCallArgs
				if len(goCCallArgs) > 0 {
					goCCallArgs = fmt.Sprintf("c.c, %s", goCCallArgs)
				} else {
					goCCallArgs = "c.c"
				}
				var goCCallDef string
				cmdName := fmt.Sprintf("C.gl_wrap_context_%s", cmd.Name)
				if len(goReturnType) > 0 {
					stars := strings.Count(cmdDetail.Proto.Raw, "*")
					if stars > 0 {
						// Pointer return type
						goCCallDef = fmt.Sprintf("return (%s)(unsafe.Pointer(%s(%s)))", goReturnType[1:], cmdName, goCCallArgs)
					} else {
						// Normal return type
						goCCallDef = fmt.Sprintf("return %s(%s(%s))", goReturnType[1:], cmdName, goCCallArgs)
					}
				} else {
					goCCallDef = fmt.Sprintf("%s(%s)", cmdName, goCCallArgs)
				}

				cArgs := cArgsBuf.String()
				if strings.HasSuffix(cArgs, ", ") {
					// Strip ", " from end
					cArgs = cArgs[:len(cArgs)-2]
				}
				if len(cArgs) == 0 {
					cArgs = "void"
				}

				cNamedArgs := cNamedArgsBuf.String()
				if strings.HasSuffix(cNamedArgs, ", ") {
					// Strip ", " from end
					cNamedArgs = cNamedArgs[:len(cNamedArgs)-2]
				}
				if len(cNamedArgs) == 0 {
					cNamedArgs = "void"
				}

				// Create TmplFunction
				goName := cmd.Name
				if strings.HasPrefix(goName, "gl") {
					goName = goName[2:]
				}
				tmplData.Functions = append(tmplData.Functions, TmplFunction{
					GoName:         goName,
					GoArgs:         args,
					GoReturns:      goReturnType,
					GoCCallDef:     goCCallDef,
					GoCHandlerArgs: goCHandlerArgs,

					CName:      cmd.Name,
					CCapsName:  strings.ToUpper(cmd.Name),
					CArgs:      cArgs,
					CNamedArgs: cNamedArgs,
					CReturns:   cReturnType,
					CArgsPairs: cArgsPairs,
				})
			}
		}
	}

	// Begin wrapper generation
	for api, tmplData := range apis {
		// Create package directory
		pkgDirPath := filepath.Join(outputDir, api)
		log.Printf("mkdir %s\n", pkgDirPath)

		err = os.MkdirAll(pkgDirPath, 0777)
		if err != nil {
			log.Fatal(err)
		}

		// Write enums file
		enumsFilePath := filepath.Join(pkgDirPath, "enums.go")
		log.Printf("  create %s\n", enumsFilePath)
		enumsFile, err := os.Create(enumsFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeEnums(enumsFile, tmplData)
		if err != nil {
			log.Fatal(err)
		}

		enumsFile.Close()

		// Write gogl file
		goglFilePath := filepath.Join(pkgDirPath, "gl.go")
		log.Printf("  create %s\n", goglFilePath)
		goglFile, err := os.Create(goglFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeGoGL(goglFile, tmplData, false)
		if err != nil {
			log.Fatal(err)
		}

		goglFile.Close()

		// Write gogl debug file
		goglDebugFilePath := filepath.Join(pkgDirPath, "gldebug.go")
		log.Printf("  create %s\n", goglDebugFilePath)
		goglDebugFile, err := os.Create(goglDebugFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeGoGL(goglDebugFile, tmplData, true)
		if err != nil {
			log.Fatal(err)
		}

		goglDebugFile.Close()

		// Write goTypes file
		goTypesFilePath := filepath.Join(pkgDirPath, "types.go")
		log.Printf("  create %s\n", goTypesFilePath)
		goTypesFile, err := os.Create(goTypesFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeGoTypes(goTypesFile, tmplData)
		if err != nil {
			log.Fatal(err)
		}

		goTypesFile.Close()

		// Write cHeader file
		cHeaderFilePath := filepath.Join(pkgDirPath, "gl.h")
		log.Printf("  create %s\n", cHeaderFilePath)
		cHeaderFile, err := os.Create(cHeaderFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeCHeader(cHeaderFile, tmplData.Functions, tmplData.CTypes, tmplData.CapsName)
		if err != nil {
			log.Fatal(err)
		}

		cHeaderFile.Close()

		// Write cCode file
		cCodeFilePath := filepath.Join(pkgDirPath, "gl.c")
		log.Printf("  create %s\n", cCodeFilePath)
		cCodeFile, err := os.Create(cCodeFilePath)
		if err != nil {
			log.Fatal(err)
		}

		err = writeCCode(cCodeFile, tmplData.Functions, tmplData.CTypes)
		if err != nil {
			log.Fatal(err)
		}

		cCodeFile.Close()
	}
}
